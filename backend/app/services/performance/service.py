"""
Performance tracking and calculation service.

This service manages the storage, aggregation, and reporting of daily performance metrics based on closed (realized) trades.

Daily performance records are generated by combining the account's financial snapshot
(with get_balance()) with aggregated data from closed trades (with get_position_history()). This
ensures that all performance data reflects finalized outcomes that do not change over time.
"""

from datetime import datetime
from decimal import Decimal
from typing import Dict, List, Optional, Any
import asyncio

from app.core.errors.base import (
    DatabaseError,
    ValidationError,
    NotFoundError,
    ServiceError
)
from app.core.logging.logger import get_logger
from app.core.references import PerformanceMetrics, DateRange, PerformanceDict, TimeSeriesData

from app.services.performance.aggregator import PerformanceAggregator
from app.services.performance.calculator import PerformanceCalculator
from app.services.performance.storage import PerformanceStorage

from app.core.errors.decorators import error_handler

logger = get_logger(__name__)


class PerformanceService:
    """
    Service for managing and calculating performance metrics based on closed (realized) trades.

    Daily performance records are generated by combining the account's financial snapshot
    (via get_balance()) with aggregated data from closed trades (via get_position_history()). This
    ensures that all performance data reflects finalized outcomes that do not change over time.
    """
    def __init__(self) -> None:
        """Initialize performance service components."""
        try:
            self.calculator = PerformanceCalculator()
            self.aggregator = PerformanceAggregator()
            self.storage = PerformanceStorage()
            self.logger = get_logger(__name__)
        except Exception as e:
            raise ServiceError(
                "Failed to initialize performance service",
                context={"error": str(e)}
            )

    @error_handler(
        context_extractor=lambda self, account_id, date, balance, equity, metrics: {
            "account_id": account_id,
            "date": date.isoformat(),
            "balance": str(balance),
            "equity": str(equity),
            "metrics": metrics.dict()
        },
        log_message="Failed to update daily performance"
    )
    async def update_daily_performance(
        self,
        account_id: str,
        date: datetime,
        balance: Decimal,
        equity: Decimal,
        metrics: PerformanceDict,
    ) -> None:
        """
        Update the daily performance record based on realized (closed-trade) data.

        Args:
            account_id: The account for which to update performance.
            date: The performance date (typically set to midnight UTC for that day).
            balance: The current account balance.
            equity: The current account equity.
            metrics: A dictionary containing performance metrics derived from closed trades.
                     Expected keys include:
                       - closed_trades: Count of finalized (closed) trades for the day.
                       - closed_trade_value: Total notional value of those closed trades.
                     (Other fields such as realized PnL, fees, etc., may also be included.)
        Raises:
            ValidationError: If balance or equity values are invalid.
            DatabaseError: If saving the performance record fails.
        """
        if balance <= 0 or equity <= 0:
            raise ValidationError(
                "Invalid balance/equity values",
                context={"balance": str(balance), "equity": str(equity)}
            )
        # Use an inline lock to protect the update operation.
        async with asyncio.Lock():
            record = await self.storage.get_daily_performance(account_id, date)
            if record:
                # Update existing record
                for key, value in metrics.dict().items():
                    setattr(record, key, value)
                record.modified_at = datetime.utcnow()
            else:
                record = self.storage.create_daily_performance(account_id, date, metrics)
            await record.save()
        self.logger.info(
            "Updated daily performance",
            extra={"account_id": account_id, "date": date.isoformat(), "metrics": metrics.dict()}
        )

    @error_handler(
        context_extractor=lambda self, account_id, time_range: {
            "account_id": account_id,
            "start_date": time_range.start_date.isoformat(),
            "end_date": time_range.end_date.isoformat()
        },
        log_message="Failed to get account metrics"
    )
    async def get_account_metrics(
        self,
        account_id: str,
        time_range: DateRange,
    ) -> PerformanceMetrics:
        """
        Get account performance metrics for a specified time range.

        This method retrieves the pre-computed daily performance records (generated using closed trades)
        from storage and aggregates them to produce overall metrics.
        
        Args:
            account_id: Account identifier.
            time_range: Date range for performance data.
        Returns:
            A PerformanceMetrics instance with aggregated values.
        Raises:
            NotFoundError: If no performance data is found.
            DatabaseError: If retrieval or aggregation fails.
        """
        time_range_str = f"{time_range.start_date} to {time_range.end_date}"
        data = await self.storage.get_performance_data(account_id, time_range.start_date, time_range.end_date)
        if not data:
            raise NotFoundError(
                "No performance data found",
                context={"account_id": account_id, "time_range": time_range_str}
            )
        metrics = await self.calculator.calculate_period_metrics(data)
        self.logger.info(
            "Retrieved account metrics",
            extra={"account_id": account_id, "time_range": time_range_str}
        )
        return metrics

    @error_handler(
        context_extractor=lambda self, group_id, time_range: {
            "group_id": group_id,
            "start_date": time_range.start_date.isoformat(),
            "end_date": time_range.end_date.isoformat()
        },
        log_message="Failed to get group metrics"
    )
    async def get_group_metrics(
        self,
        group_id: str,
        time_range: DateRange,
    ) -> PerformanceMetrics:
        """
        Get aggregated performance metrics for a group of accounts.

        This method fetches all accounts within the specified group, retrieves their daily performance
        records (each built from closed trades), and aggregates them into a unified summary.
        
        Args:
            group_id: Group identifier.
            time_range: Date range for performance data.
        Returns:
            Aggregated PerformanceMetrics.
        Raises:
            NotFoundError: If no accounts or performance data are found.
            DatabaseError: If aggregation fails.
        """
        time_range_str = f"{time_range.start_date} to {time_range.end_date}"
        from app.services.reference.manager import reference_manager
        accounts = await reference_manager.get_references(source_type="Group", reference_id=group_id)
        if not accounts:
            raise NotFoundError(
                "No accounts found for group",
                context={"group_id": group_id}
            )
        tasks = {
            str(account["id"]): asyncio.create_task(
                self.storage.get_performance_data(str(account["id"]), time_range.start_date, time_range.end_date)
            )
            for account in accounts
        }
        account_data = {account_id: data for account_id, data in ((aid, await task) for aid, task in tasks.items()) if data}
        metrics = await self.aggregator.aggregate_group_metrics(account_data)
        self.logger.info(
            "Retrieved group metrics",
            extra={"group_id": group_id, "account_count": len(account_data), "time_range": time_range_str}
        )
        return metrics

    @error_handler(
        context_extractor=lambda self, account_ids, start_date, end_date, interval="day": {
            "account_count": len(account_ids),
            "interval": interval,
            "start_date": start_date.isoformat(),
            "end_date": end_date.isoformat()
        },
        log_message="Failed to aggregate performance"
    )
    async def aggregate_performance(
        self,
        account_ids: List[str],
        start_date: datetime,
        end_date: datetime,
        interval: str = "day",
    ) -> TimeSeriesData:
        """
        Aggregate daily performance data from multiple accounts into a time series.

        Args:
            account_ids: List of account identifiers.
            start_date: Start date of the time range.
            end_date: End date of the time range.
            interval: Aggregation interval (e.g., "day", "week", "month", "year").
        Returns:
            A dictionary representing the aggregated time series data.
        Raises:
            ValidationError: If the account list is empty or the date range is invalid.
            DatabaseError: If aggregation fails.
        """
        if not account_ids:
            raise ValidationError("No accounts provided", context={"account_ids": account_ids, "interval": interval})
        if start_date >= end_date:
            raise ValidationError("Invalid date range", context={"start_date": start_date.isoformat(), "end_date": end_date.isoformat()})
        tasks = {
            account_id: asyncio.create_task(
                self.storage.get_performance_data(account_id, start_date, end_date)
            )
            for account_id in account_ids
        }
        account_data = {account_id: data for account_id, data in ((aid, await task) for aid, task in tasks.items()) if data}
        aggregated = await self.aggregator.aggregate_by_interval(data=account_data, interval=interval)
        self.logger.info(
            "Aggregated performance data",
            extra={"account_count": len(account_ids), "interval": interval, "time_range": f"{start_date.isoformat()} to {end_date.isoformat()}"}
        )
        return aggregated


# Global instance of the performance service.
performance_service = PerformanceService()
